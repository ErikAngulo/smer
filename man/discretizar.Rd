% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modifications.R
\name{discretizar}
\alias{discretizar}
\title{Discretización de variables continuas}
\usage{
discretizar(ds, metodo, puntos_corte, columnas)
}
\arguments{
\item{ds}{Objeto de tipo Dataset.}

\item{metodo}{Algoritmo de discretización. Con valor 'frecuencia' se aplicará
discretización por igual frecuencia. Con valor 'anchura' se aplicará discretización
por igual anchura. Con valor 'manual' se discretizará con los tramos obtenidos
en otro algoritmo de discretización ya ejecutado o con los tramos deseados.}

\item{puntos_corte}{Cuántos puntos de corte se desean (el valor + 1 serán los tramos).
Si el valor del parámetro 'metodo' es 'manual', se deberá indicar en este parámetro
cuáles son los puntos de corte a través de un vector.}

\item{columnas}{El índice de columnas a las que se aplicará la discretización.
Las columnas deberán ser numéricas y no deberán estar ya factorizadas.}
}
\value{
Un nuevo \code{\linkS4class{Dataset}} con las columnas proporcionadas
discretizadas y factorizadas.
}
\description{
Discretiza las columnas seleccionadas de un \code{\linkS4class{Dataset}}
con el número de tramos o puntos de corte proporcionados.
}
\details{
Uno de los algoritmos clásicos es equal width (igual anchura). Dado un vector de números reales y un número de intervalos, determina cuales son los puntos de corte para generar un vector categórico de tal manera que esos puntos están uniformemente distribuidos en el rango de los valores.
Por ejemplo, si tenemos los valores (11.5, 10.2, 1.2, 0.5, 5.3, 20.5, 8.4) y queremos generar una variable categórica (su implementación en Python puede ser como un string) con cuatro posibles valores, tenemos que determinar tres puntos de corte, que serán valores que separen el intervalo (entre 0.5 y 20.5 en este caso) en 4 tramos de igual tamaño. Es decir, el primer tramo irá de 0.5 a 5.5, el segundo de 5.5 a 10.5, el tercero de 10.5 a 15.5 y el último de 15.5 a 20.5. Es decir, tendríamos 3 puntos de corte, 5.5, 10.5 y 15.5.
Normalmente cuando se lleva a cabo esta tarea, ante un nuevo valor es necesario determinar a que intervalo pertence. Dado que cuando eso ocurre el valor puede estar fuera de los límites del vector original, el comienzo del primer tramos se suele considerar -infinito y el final del último como infinito. Es decir, una vez aplicado el algoritmo, el resultado sería un vector categórico de este estilo:
`["I3", "I2", "I1", "I1", "I4", "I2"]`, donde I1=(-infinito, 5.5], I2=(5.5, 10.5], I3=(10.5, 15.5], I4=(15.5, infinito).
Otro de los algoritmos clásicos es equal frequency (igual frecuencia), donde el objetivo es buscar los puntos de corte que hagan que el número de valores del vector a discretizar que caen en cada uno de los intervalos sea el mismo (+- 1, según el número de intervalos y de puntos).
}
